package com.rethinkdb.orm;

import com.rethinkdb.gen.ast.Table;
import com.rethinkdb.net.Connection;
import com.rethinkdb.orm.entities.EntityArray;
import com.rethinkdb.orm.entities.EntityEmbedded;
import com.rethinkdb.orm.entities.EntityNonExistingDbName;
import com.rethinkdb.orm.entities.EntityOne;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;

import static com.rethinkdb.RethinkDB.r;

public class CreateTests extends BaseTest {

	@BeforeClass
	public static void before() {

		BaseTest.before();

		rdb.register(EntityOne.class);
		rdb.register(EntityArray.class);
		rdb.register(EntityEmbedded.class);

		rdb.tablePurge(EntityArray.class);
		rdb.tablePurge(EntityEmbedded.class);
		rdb.tablePurge(EntityOne.class);
	}

	@Test(expected = IllegalStateException.class)
	public void nonExistingDbName() {

		rdb.register(EntityNonExistingDbName.class);  // throws IllegalStateException because DB does not exist
	}

	@Test
	public void simpleTest() {

		try (Connection conn = rdb.getConnection()) {
			Table t = rdb.table(EntityOne.class);
			t.run(conn);
		}
	}

	@Test
	public void getNumberId() {

		EntityOne entity = TestUtils.randomEntityOne();

		Object returnedId = rdb.create(entity);
		Assert.assertEquals(entity.userId, returnedId);

		EntityOne res = rdb.get(EntityOne.class, entity.userId);
		Assert.assertEquals(entity, res);
	}

	@Test
	public void ignoreNullField() {

		EntityOne entity = TestUtils.randomEntityOne();

		// this will make RDB skip this field on write
		entity.eight = null;

		Object returnedId = rdb.create(entity);
		Assert.assertEquals(entity.userId, returnedId);

		try (Connection conn = rdb.getConnection()) {
			Boolean hasFieldTwo = rdb.table(EntityOne.class).get(returnedId).keys().contains("two").run(conn);
			Assert.assertTrue(hasFieldTwo);

			Boolean hasFieldEight = rdb.table(EntityOne.class).get(returnedId).keys().contains("eight").run(conn);
			Assert.assertFalse(hasFieldEight);
		}
	}

	@Test
	public void autogenerateId() {

		EntityOne entity = TestUtils.randomEntityOne();
		entity.userId = null;

		Object returnedId = rdb.create(entity);
		Assert.assertNotNull(returnedId);

		EntityOne res = rdb.get(EntityOne.class, entity.userId);
		Assert.assertEquals(entity, res);
	}

	@Test
	public void replaceSame() {

		EntityOne entity = TestUtils.randomEntityOne();
		entity.userId = null;

		Object returnedId = rdb.create(entity);
		Assert.assertNotNull(returnedId);

		// replace with same entity
		Object res = rdb.replace(entity);
		Assert.assertEquals(entity.userId, res);
	}

	@Test
	public void autogenerateDelete() {

		EntityOne entity = TestUtils.randomEntityOne();
		entity.userId = null;

		Object returnedId = rdb.create(entity);
		Assert.assertNotNull(returnedId);

		Boolean deleted = rdb.delete(entity);
		Assert.assertTrue(deleted);

		EntityOne res = rdb.get(EntityOne.class, entity.userId);
		Assert.assertNull(res);
	}

	@Test
	public void getArrayId() {


		EntityArray arrays = new EntityArray();
		arrays.id = new int[]{11, 12, 13};
		arrays.doubles = new double[]{1.23456556d, 0.0d, 100.0d};
		arrays.floats = new float[]{1.234565f, 34234.2132f, 100.0f};
		arrays.bytes = new byte[]{1, 2, 3};
		arrays.ints = new int[]{234872348, 5};
		arrays.longs = new long[]{2348723484L, 12123123123L};
		arrays.shorts = new short[]{32444, 32325};
		arrays.booleans = new boolean[]{true, true, false};

		// we provide an array of floats as ID
		rdb.create(arrays);

		EntityArray res = rdb.get(EntityArray.class, arrays.id);

		Assert.assertEquals(arrays, res);
	}

	@Test
	public void getArrayIntegers() {

		try (Connection conn = rdb.getConnection()) {

			// integer array
			int[] ids = new int[]{1, 2, 3};

			// we provide an array of floats as ID
			rdb.table(EntityArray.class).insert(r.hashMap("id", r.array(1.0f, 2.0f, 3.0f))).run(conn);

			EntityArray res = rdb.get(EntityArray.class, ids);

			// id arrays have equal values
			Assert.assertEquals(ids.length, res.id.length);
			for (int i = 0; i < ids.length; i++) {
				Assert.assertEquals(ids[i], res.id[i]);
			}
		}
	}

//	@Test(expected = RuntimeException.class)
//	public void unsupportedIdArrayType() {
//
//		try (Connection conn = rdb.getConnection()) {
//		// integer array
//		byte[] ids = new byte[]{1, 2, 3};
//		EntityOne res = rdb.get(EntityOne.class, ids);
//      }
//	}

	@Test
	public void geoData() {

		try (Connection conn = rdb.getConnection()) {

			// we provide an array of floats as ID
			rdb.table(EntityOne.class).insert(r.hashMap("id", "geo1")
				.with("point", r.point(1, 2))
				.with("line", r.line(r.point(1, 2), r.point(3, 4)))
				.with("poly", r.polygon(r.point(1, 2), r.point(3, 4), r.point(5, 6)))
			).run(conn);
			EntityOne res = rdb.get(EntityOne.class, "geo1");
		}
		//todo write assert

	}

	// todo write tests to check various combinations of tableNames (class, field, default)


}
